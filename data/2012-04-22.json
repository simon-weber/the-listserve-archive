["[The Listserve] Volatile Software", "Steve Losh", "I want to use my fifteen minutes of fame on The Listserve to rant about\r\nsomething that's close to my heart: the stability of the software I use.\r\n\r\nNOTE: This is written for people who create software.  If you don't do that you\r\nprobably won't find this very interesting.  Sorry!  Maybe you could read Text\r\nfrom Dog if you haven't seen it already?  Either way, have a nice\r\nmorning/afternoon/evening!\r\n\r\nThe Situation\r\n-------------\r\n\r\nEvery time I get a new computer, I go through the same song and dance:\r\n\r\n1. Look at what programs and packages I have installed on the old computer.\r\n2. Install these programs on the new computer.\r\n3. Copy over my configuration files from the old computer to the new one.\r\n4. Spend the rest of my day fixing all the things that broke because I'm using\r\n    a newer version of program X.\r\n\r\nStep 4 is always the most painful part of getting a new machine.  Always.\r\n\r\nWithout fail I spend several hours tweaking configuration files, adjusting my\r\nworkflow, and so on because I've upgraded to a new version of foo which doesn't\r\nsupport option X any more or requires library Y version N+1 now.\r\n\r\nGetting a new computer should be a *pleasant* experience!  The unboxing from the\r\nsleek packaging, that \"new laptop\" smell, the nostalgia of the default desktop\r\nimage.  Why does this horrible step 4 have to exist and how can we get rid of\r\nit?\r\n\r\nThe Divide\r\n----------\r\n\r\nI've noticed something interesting lately: I can categorize almost *all* of the\r\nsoftware I use into two distinct groups:\r\n\r\n* Software that breaks pretty much *every* time I update it (e.g. weechat,\r\n  offlineimap, Clojure, many Python packages, Skype).\r\n* Software that almost *never* breaks when I update it (e.g. Mercurial, git,\r\n  tmux, Python, ack, zsh, Vim, Dropbox).\r\n\r\nSoftware that falls in between these two extremes is surprisingly rare.  There\r\nseems to be a pretty clean divide between the two groups.\r\n\r\nThis makes me think that there's some special attribute or quality of the\r\nsecond group (or its authors) which the first one lacks.\r\n\r\nBrokenness\r\n----------\r\n\r\nI think it's important that I nail down what I mean by \"breaks\" or \"is broken\".\r\nI don't necessarily just mean the introduction of \"new bugs\".\r\n\r\nWhen I say that a program \"breaks\", I mean:\r\n\r\n* When I update from version X to version Y of a program, library, or language...\r\n* Without changing my configuration files, source code, etc...\r\n* The resulting combination doesn't work properly\r\n\r\nIn effect, I'm saying that \"breaking backwards compatibility\" means \"the program\r\nis broken\"!\r\n\r\nThis may be a strong statement, but I stand by it in most cases.\r\n\r\nBackwards compatibility matters!  Every time someone makes a backwards\r\nincompatible change in a program or library, they cost the world the following\r\namount of time:\r\n\r\n    Number of people          Time it takes each person\r\n    using that part of      X    to figure out what changed\r\n    the program                   and how to fix it\r\n \r\nOften this can be a significant amount of time!\r\n\r\nThe Process of Updating\r\n-----------------------\r\n\r\nWhen pointing out a backwards incompatible change to someone, you'll often get\r\na response similar to this:\r\n\r\n    \"Well, I mentioned that backwards incompatibility in the changelog, so what\r\n    the hell, man!\"\r\n\r\nThis is not a satisfactory answer.\r\n\r\nWhen I'm updating a piece of software there's a good chance it's not because I'm\r\nspecifically updating *that program*.  I might be:\r\n\r\n* Moving to a new computer.\r\n* Running a \"$PACKAGE_MANAGER update\" command.\r\n* Moving a website to a bigger VPS and reinstalling all the libraries.\r\n\r\nIn those cases (and many others) I'm not reading the release notes for\r\na specific program or library.  I'm not going to find out about the brokenness\r\nuntil I try to use the program the next time.\r\n\r\nIf I'm lucky the program will have a \"this feature is now deprecated, read the\r\ndocs\" error message.  That's still a pain, but at least it's less confusing than\r\njust getting a traceback, or worst of all: silently changing the behavior of\r\na feature.\r\n\r\nProgress\r\n--------\r\n\r\nI completely understand that when moving *backwards* to an older version\r\nI should expect problems.  The older version hasn't had the benefit of the extra\r\nwork done on the new version, so of course it should be less stable.\r\n\r\nBut when I'm *updating* to a higher version number the software should be\r\n*better* and *more stable*!  It has had more work done on it, and I assume no\r\none is actively trying to make software worse, so why does something that\r\npreviously worked no longer work?\r\n\r\nWe're supposed to be making *progress* as we move forward.  The software has had\r\n*more* work done on it, why does it not function correctly *now* when it\r\nfunctioned correctly *before*?\r\n\r\nYes, this means developers will need to add extra code to handle old\r\ninput/configuration.  Yes, this is a pain in the ass, but *the entire point of\r\nmost software is to save people time by automating things*.  Again, every\r\nbackwards-incompatible change costs the world an amount of time:\r\n\r\n    Number of people         Time it takes each person\r\n    using that part of     X      to figure out what changed\r\n    the program                  and how to fix it\r\n\r\nIf our goal is to *save time* then we should not make changes that *cost time*.\r\nOr at least we should not make such changes lightly.\r\n\r\nA Culture of Sadness\r\n--------------------\r\n\r\nProof that this is a real issue can be found in the tools we use every day.  As\r\nprogrammers we've invented elaborate dependency systems to deal with it.\r\n\r\nWe say \"pip install django==1.3\" or put \"[clojure \"1.2\"]\" in our Leiningen\r\nproject.clj files to avoid using the newest versions because they'll break.\r\n\r\nStep back and look at this for a second.\r\n\r\nWhat the hell?\r\n\r\nWhat the *hell*?\r\n\r\nWe have invented software with features designed to help us use *old* versions\r\nof other software!\r\n\r\nWe have *written code* to *avoid* using the \"latest and greatest\" software!\r\n\r\nObviously this is not entirely bad, but the fact that manually specifying\r\nversion numbers to avoid running *newer* code is commonplace, expected, and\r\na \"best practice\" horrifies me.\r\n\r\nI would *love* to be able to say something like this in my requirements.txt and\r\nproject.clj files:\r\n\r\n    Of *course* I want the latest version of library X!  I want *all* the\r\n    newest bug fixes and improvements!\r\n\r\nUnfortunately I can't do that right now because so many projects make backwards\r\nincompatible changes all the time.\r\n\r\nThe moment I try to build the project at some point in the future I'll be sent\r\non a wild goose chase to figure out what function moved into what other\r\nnamespace and what other function was split into its own library and dammit the\r\ndocumentation on the project's website is autogenerated from the tip of its git\r\nrepo and so it doesn't apply to the latest actual version and jesus christ\r\nI think I'll just quit programming and teach dance full time instead even though\r\nI'll go hungry.\r\n\r\nThe Tradeoff\r\n------------\r\n\r\nOne could argue that sometimes backwards incompatible changes cost time up front\r\nbut save time in the long run by making the software more \"elegant\" and \"lean\".\r\n\r\nWhile I'm sure there are cases where this is true, I feel like it's a cop out\r\nmost of the time.  Allow me to illustrate this with a helpful Venn diagram:\r\n\r\n                                    -------\r\n                                   /3333333\\\r\n                                  |333333333|\r\n                                   \\3333333/\r\n                                    -------\r\n\r\n    11 -> People who give a shit what a program's codebase\r\n    11    looks like.\r\n\r\n    22 -> The authors of said program.\r\n    22\r\n\r\nFor libraries where the author is the only user, none of this rant applies.\r\nYou're free!  Break as much as you like!\r\n\r\nFor the majority of libraries, however, there are probably vastly more \"users\"\r\nthan \"authors\".  Saving a few hours of the authors' own time has to be weighed\r\nagainst the 10 minutes each that the hundreds of users will have to spend\r\nfiguring out what happened and working around it.\r\n\r\nI want to be clear: being backwards compatible *doesn't* mean sacrificing new\r\nfeatures!  New features can still be added!  Refactoring can still happen!\r\n\r\nIn most cases keeping backwards compatibility simply means maintaining a bit of\r\nwrapper code to support people using the previous version.\r\n\r\nFor example: in Python, if we moved the public foo() function to a new module,\r\nwe'd put the following line in the original module:\r\n\r\n    from newmodule import new_foo as foo\r\n\r\nIs it pretty?  Hell no!  But this single line of code will probably save more\r\npeople more time than most of the other lines in the project!\r\n\r\nThis may just be an artifact of how my brain is wired, but I actually get\r\na sense of satisfaction from writing code that bridges the gap between older\r\nversions and new.\r\n\r\nI can almost hear a little voice in my head saying:\r\n\r\n    \"Mwahaha, I'll slip this refactoring past them and they'll never even know\r\n    it happened!\"\r\n\r\nMaybe it's just me, but I think that \"glue\" code can be clever and beautiful in\r\nits own right.\r\n\r\nIt may not bring a smile to anyone's face like a shiny new feature, but it\r\nprevents many frowns instead, and preventing a frown makes the world a happier\r\nplace just as much as creating a smile!\r\n\r\nExceptions\r\n----------\r\n\r\nOne case where I feel the backwards incompatibility tradeoff *is* worth it is\r\nsecurity.\r\n\r\nA good example of this is Django's change which made AJAX requests no longer be\r\nexempt from CSRF checks.  It was backwards incompatible and I'm sure it broke\r\nsome people's projects, but I think it was the right thing to do because it\r\nimproved security.\r\n\r\nI also think it's unreasonable to expect all software to be perfectly ready from\r\nits first day.\r\n\r\nSometimes software needs to get poked and prodded in the real world before it's\r\nfully baked, and until then requiring strict backwards compatibility will do\r\nmore harm than good.\r\n\r\nBy all means, backwards compatibility should be thrown to the wind in the first\r\nstage of a project's life.  At the beginning it needs to find its legs, like\r\na baby gazelle on the Serengeti.  But at some point the project needs to get its\r\nbalance, grow up, and start concerning itself with backwards compatibility.\r\n\r\nBut when should that happen?\r\n\r\nA Solution\r\n----------\r\n\r\nI think there's a simple, intuitive way to mark the transition of a piece of\r\nsoftware from \"volatile\" to \"stable\":\r\n\r\n    Version 1.0\r\n\r\nBefore version 1, software can change and evolve rapidly with no regards for\r\nbreaking, but once that first number becomes \"greater than or equal to 1\" it's\r\ntime to be a responsible member of the software community and start thinking\r\nabout the real humans whose time gets wasted for every breaking change.\r\n\r\nThis is the approach semantic versioning takes, and I think it's the right one.\r\n\r\nI know a lot of people dislike semantic versioning.  They hate how requires\r\nincrementing the major version number every time a breaking change is made.\r\n\r\nI consider it to be a *good* thing.\r\n\r\nYou *should* pause and carefully consider making a change that will break\r\npeople's current code.\r\n\r\nYou *should* be ashamed if your project is at version 43.0.0 because you've made\r\n42 breaking changes.  That's 43 times you've disregarded your users' time!\r\nThat's a bad thing!\r\n\r\nAs programmers we need to start caring about the people we write software for.\r\n\r\nBefore making a change that's going to cause other people pain, we should ask\r\nourselves if it's really worth the cost.  Sometimes it is, but many times it's\r\nnot, and we can wrap the change up so it doesn't hurt anyone.\r\n\r\nSo please, before you make that backwards incompatible change, think of the\r\nother human beings who are going to smack their monitors when your software\r\nbreaks.\r\n\r\nFurther Reading\r\n-------------", [2012, 4, 22]]
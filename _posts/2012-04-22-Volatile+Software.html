---
layout: post
title: "Volatile Software"
description: "A post from The Listserve"
---

<h2 id='post-title'>
{{ page.title }}
</h2>

<p class="meta">April 22 2012</p>

<p>I want to use my fifteen minutes of fame on The Listserve to rant about<br />something that's close to my heart: the stability of the software I use.</p>
<p>NOTE: This is written for people who create software.  If you don't do that you<br />probably won't find this very interesting.  Sorry!  Maybe you could read Text<br />from Dog if you haven't seen it already?  Either way, have a nice<br />morning/afternoon/evening!</p>
<p>The Situation<br />-------------</p>
<p>Every time I get a new computer, I go through the same song and dance:</p>
<p>1. Look at what programs and packages I have installed on the old computer.<br />2. Install these programs on the new computer.<br />3. Copy over my configuration files from the old computer to the new one.<br />4. Spend the rest of my day fixing all the things that broke because I'm using<br />    a newer version of program X.</p>
<p>Step 4 is always the most painful part of getting a new machine.  Always.</p>
<p>Without fail I spend several hours tweaking configuration files, adjusting my<br />workflow, and so on because I've upgraded to a new version of foo which doesn't<br />support option X any more or requires library Y version N+1 now.</p>
<p>Getting a new computer should be a *pleasant* experience!  The unboxing from the<br />sleek packaging, that "new laptop" smell, the nostalgia of the default desktop<br />image.  Why does this horrible step 4 have to exist and how can we get rid of<br />it?</p>
<p>The Divide<br />----------</p>
<p>I've noticed something interesting lately: I can categorize almost *all* of the<br />software I use into two distinct groups:</p>
<p>* Software that breaks pretty much *every* time I update it (e.g. weechat,<br />  offlineimap, Clojure, many Python packages, Skype).<br />* Software that almost *never* breaks when I update it (e.g. Mercurial, git,<br />  tmux, Python, ack, zsh, Vim, Dropbox).</p>
<p>Software that falls in between these two extremes is surprisingly rare.  There<br />seems to be a pretty clean divide between the two groups.</p>
<p>This makes me think that there's some special attribute or quality of the<br />second group (or its authors) which the first one lacks.</p>
<p>Brokenness<br />----------</p>
<p>I think it's important that I nail down what I mean by "breaks" or "is broken".<br />I don't necessarily just mean the introduction of "new bugs".</p>
<p>When I say that a program "breaks", I mean:</p>
<p>* When I update from version X to version Y of a program, library, or language...<br />* Without changing my configuration files, source code, etc...<br />* The resulting combination doesn't work properly</p>
<p>In effect, I'm saying that "breaking backwards compatibility" means "the program<br />is broken"!</p>
<p>This may be a strong statement, but I stand by it in most cases.</p>
<p>Backwards compatibility matters!  Every time someone makes a backwards<br />incompatible change in a program or library, they cost the world the following<br />amount of time:</p>
<p>    Number of people          Time it takes each person<br />    using that part of      X    to figure out what changed<br />    the program                   and how to fix it<br /> <br />Often this can be a significant amount of time!</p>
<p>The Process of Updating<br />-----------------------</p>
<p>When pointing out a backwards incompatible change to someone, you'll often get<br />a response similar to this:</p>
<p>    "Well, I mentioned that backwards incompatibility in the changelog, so what<br />    the hell, man!"</p>
<p>This is not a satisfactory answer.</p>
<p>When I'm updating a piece of software there's a good chance it's not because I'm<br />specifically updating *that program*.  I might be:</p>
<p>* Moving to a new computer.<br />* Running a "$PACKAGE_MANAGER update" command.<br />* Moving a website to a bigger VPS and reinstalling all the libraries.</p>
<p>In those cases (and many others) I'm not reading the release notes for<br />a specific program or library.  I'm not going to find out about the brokenness<br />until I try to use the program the next time.</p>
<p>If I'm lucky the program will have a "this feature is now deprecated, read the<br />docs" error message.  That's still a pain, but at least it's less confusing than<br />just getting a traceback, or worst of all: silently changing the behavior of<br />a feature.</p>
<p>Progress<br />--------</p>
<p>I completely understand that when moving *backwards* to an older version<br />I should expect problems.  The older version hasn't had the benefit of the extra<br />work done on the new version, so of course it should be less stable.</p>
<p>But when I'm *updating* to a higher version number the software should be<br />*better* and *more stable*!  It has had more work done on it, and I assume no<br />one is actively trying to make software worse, so why does something that<br />previously worked no longer work?</p>
<p>We're supposed to be making *progress* as we move forward.  The software has had<br />*more* work done on it, why does it not function correctly *now* when it<br />functioned correctly *before*?</p>
<p>Yes, this means developers will need to add extra code to handle old<br />input/configuration.  Yes, this is a pain in the ass, but *the entire point of<br />most software is to save people time by automating things*.  Again, every<br />backwards-incompatible change costs the world an amount of time:</p>
<p>    Number of people         Time it takes each person<br />    using that part of     X      to figure out what changed<br />    the program                  and how to fix it</p>
<p>If our goal is to *save time* then we should not make changes that *cost time*.<br />Or at least we should not make such changes lightly.</p>
<p>A Culture of Sadness<br />--------------------</p>
<p>Proof that this is a real issue can be found in the tools we use every day.  As<br />programmers we've invented elaborate dependency systems to deal with it.</p>
<p>We say "pip install django==1.3" or put "[clojure "1.2"]" in our Leiningen<br />project.clj files to avoid using the newest versions because they'll break.</p>
<p>Step back and look at this for a second.</p>
<p>What the hell?</p>
<p>What the *hell*?</p>
<p>We have invented software with features designed to help us use *old* versions<br />of other software!</p>
<p>We have *written code* to *avoid* using the "latest and greatest" software!</p>
<p>Obviously this is not entirely bad, but the fact that manually specifying<br />version numbers to avoid running *newer* code is commonplace, expected, and<br />a "best practice" horrifies me.</p>
<p>I would *love* to be able to say something like this in my requirements.txt and<br />project.clj files:</p>
<p>    Of *course* I want the latest version of library X!  I want *all* the<br />    newest bug fixes and improvements!</p>
<p>Unfortunately I can't do that right now because so many projects make backwards<br />incompatible changes all the time.</p>
<p>The moment I try to build the project at some point in the future I'll be sent<br />on a wild goose chase to figure out what function moved into what other<br />namespace and what other function was split into its own library and dammit the<br />documentation on the project's website is autogenerated from the tip of its git<br />repo and so it doesn't apply to the latest actual version and jesus christ<br />I think I'll just quit programming and teach dance full time instead even though<br />I'll go hungry.</p>
<p>The Tradeoff<br />------------</p>
<p>One could argue that sometimes backwards incompatible changes cost time up front<br />but save time in the long run by making the software more "elegant" and "lean".</p>
<p>While I'm sure there are cases where this is true, I feel like it's a cop out<br />most of the time.  Allow me to illustrate this with a helpful Venn diagram:</p>
<p>                                    -------<br />                                   /3333333\<br />                                  |333333333|<br />                                   \3333333/<br />                                    -------</p>
<p>    11 -> People who give a shit what a program's codebase<br />    11    looks like.</p>
<p>    22 -> The authors of said program.<br />    22</p>
<p>For libraries where the author is the only user, none of this rant applies.<br />You're free!  Break as much as you like!</p>
<p>For the majority of libraries, however, there are probably vastly more "users"<br />than "authors".  Saving a few hours of the authors' own time has to be weighed<br />against the 10 minutes each that the hundreds of users will have to spend<br />figuring out what happened and working around it.</p>
<p>I want to be clear: being backwards compatible *doesn't* mean sacrificing new<br />features!  New features can still be added!  Refactoring can still happen!</p>
<p>In most cases keeping backwards compatibility simply means maintaining a bit of<br />wrapper code to support people using the previous version.</p>
<p>For example: in Python, if we moved the public foo() function to a new module,<br />we'd put the following line in the original module:</p>
<p>    from newmodule import new_foo as foo</p>
<p>Is it pretty?  Hell no!  But this single line of code will probably save more<br />people more time than most of the other lines in the project!</p>
<p>This may just be an artifact of how my brain is wired, but I actually get<br />a sense of satisfaction from writing code that bridges the gap between older<br />versions and new.</p>
<p>I can almost hear a little voice in my head saying:</p>
<p>    "Mwahaha, I'll slip this refactoring past them and they'll never even know<br />    it happened!"</p>
<p>Maybe it's just me, but I think that "glue" code can be clever and beautiful in<br />its own right.</p>
<p>It may not bring a smile to anyone's face like a shiny new feature, but it<br />prevents many frowns instead, and preventing a frown makes the world a happier<br />place just as much as creating a smile!</p>
<p>Exceptions<br />----------</p>
<p>One case where I feel the backwards incompatibility tradeoff *is* worth it is<br />security.</p>
<p>A good example of this is Django's change which made AJAX requests no longer be<br />exempt from CSRF checks.  It was backwards incompatible and I'm sure it broke<br />some people's projects, but I think it was the right thing to do because it<br />improved security.</p>
<p>I also think it's unreasonable to expect all software to be perfectly ready from<br />its first day.</p>
<p>Sometimes software needs to get poked and prodded in the real world before it's<br />fully baked, and until then requiring strict backwards compatibility will do<br />more harm than good.</p>
<p>By all means, backwards compatibility should be thrown to the wind in the first<br />stage of a project's life.  At the beginning it needs to find its legs, like<br />a baby gazelle on the Serengeti.  But at some point the project needs to get its<br />balance, grow up, and start concerning itself with backwards compatibility.</p>
<p>But when should that happen?</p>
<p>A Solution<br />----------</p>
<p>I think there's a simple, intuitive way to mark the transition of a piece of<br />software from "volatile" to "stable":</p>
<p>    Version 1.0</p>
<p>Before version 1, software can change and evolve rapidly with no regards for<br />breaking, but once that first number becomes "greater than or equal to 1" it's<br />time to be a responsible member of the software community and start thinking<br />about the real humans whose time gets wasted for every breaking change.</p>
<p>This is the approach semantic versioning takes, and I think it's the right one.</p>
<p>I know a lot of people dislike semantic versioning.  They hate how requires<br />incrementing the major version number every time a breaking change is made.</p>
<p>I consider it to be a *good* thing.</p>
<p>You *should* pause and carefully consider making a change that will break<br />people's current code.</p>
<p>You *should* be ashamed if your project is at version 43.0.0 because you've made<br />42 breaking changes.  That's 43 times you've disregarded your users' time!<br />That's a bad thing!</p>
<p>As programmers we need to start caring about the people we write software for.</p>
<p>Before making a change that's going to cause other people pain, we should ask<br />ourselves if it's really worth the cost.  Sometimes it is, but many times it's<br />not, and we can wrap the change up so it doesn't hurt anyone.</p>
<p>So please, before you make that backwards incompatible change, think of the<br />other human beings who are going to smack their monitors when your software<br />breaks.</p>
<p>Further Reading<br />-------------</p>
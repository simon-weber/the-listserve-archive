---
api_data:
  post:
    author: Steve Losh
    body: "I want to use my fifteen minutes of fame on The Listserve to rant about\r\
      \nsomething that's close to my heart: the stability of the software I use.\r\
      \n\r\nNOTE: This is written for people who create software.  If you don't do\
      \ that you\r\nprobably won't find this very interesting.  Sorry!  Maybe you\
      \ could read Text\r\nfrom Dog if you haven't seen it already?  Either way, have\
      \ a nice\r\nmorning/afternoon/evening!\r\n\r\nThe Situation\r\n-------------\r\
      \n\r\nEvery time I get a new computer, I go through the same song and dance:\r\
      \n\r\n1. Look at what programs and packages I have installed on the old computer.\r\
      \n2. Install these programs on the new computer.\r\n3. Copy over my configuration\
      \ files from the old computer to the new one.\r\n4. Spend the rest of my day\
      \ fixing all the things that broke because I'm using\r\n    a newer version\
      \ of program X.\r\n\r\nStep 4 is always the most painful part of getting a new\
      \ machine.  Always.\r\n\r\nWithout fail I spend several hours tweaking configuration\
      \ files, adjusting my\r\nworkflow, and so on because I've upgraded to a new\
      \ version of foo which doesn't\r\nsupport option X any more or requires library\
      \ Y version N+1 now.\r\n\r\nGetting a new computer should be a *pleasant* experience!\
      \  The unboxing from the\r\nsleek packaging, that \"new laptop\" smell, the\
      \ nostalgia of the default desktop\r\nimage.  Why does this horrible step 4\
      \ have to exist and how can we get rid of\r\nit?\r\n\r\nThe Divide\r\n----------\r\
      \n\r\nI've noticed something interesting lately: I can categorize almost *all*\
      \ of the\r\nsoftware I use into two distinct groups:\r\n\r\n* Software that\
      \ breaks pretty much *every* time I update it (e.g. weechat,\r\n  offlineimap,\
      \ Clojure, many Python packages, Skype).\r\n* Software that almost *never* breaks\
      \ when I update it (e.g. Mercurial, git,\r\n  tmux, Python, ack, zsh, Vim, Dropbox).\r\
      \n\r\nSoftware that falls in between these two extremes is surprisingly rare.\
      \  There\r\nseems to be a pretty clean divide between the two groups.\r\n\r\n\
      This makes me think that there's some special attribute or quality of the\r\n\
      second group (or its authors) which the first one lacks.\r\n\r\nBrokenness\r\
      \n----------\r\n\r\nI think it's important that I nail down what I mean by \"\
      breaks\" or \"is broken\".\r\nI don't necessarily just mean the introduction\
      \ of \"new bugs\".\r\n\r\nWhen I say that a program \"breaks\", I mean:\r\n\r\
      \n* When I update from version X to version Y of a program, library, or language...\r\
      \n* Without changing my configuration files, source code, etc...\r\n* The resulting\
      \ combination doesn't work properly\r\n\r\nIn effect, I'm saying that \"breaking\
      \ backwards compatibility\" means \"the program\r\nis broken\"!\r\n\r\nThis\
      \ may be a strong statement, but I stand by it in most cases.\r\n\r\nBackwards\
      \ compatibility matters!  Every time someone makes a backwards\r\nincompatible\
      \ change in a program or library, they cost the world the following\r\namount\
      \ of time:\r\n\r\n    Number of people          Time it takes each person\r\n\
      \    using that part of      X    to figure out what changed\r\n    the program\
      \                   and how to fix it\r\n \r\nOften this can be a significant\
      \ amount of time!\r\n\r\nThe Process of Updating\r\n-----------------------\r\
      \n\r\nWhen pointing out a backwards incompatible change to someone, you'll often\
      \ get\r\na response similar to this:\r\n\r\n    \"Well, I mentioned that backwards\
      \ incompatibility in the changelog, so what\r\n    the hell, man!\"\r\n\r\n\
      This is not a satisfactory answer.\r\n\r\nWhen I'm updating a piece of software\
      \ there's a good chance it's not because I'm\r\nspecifically updating *that\
      \ program*.  I might be:\r\n\r\n* Moving to a new computer.\r\n* Running a \"\
      $PACKAGE_MANAGER update\" command.\r\n* Moving a website to a bigger VPS and\
      \ reinstalling all the libraries.\r\n\r\nIn those cases (and many others) I'm\
      \ not reading the release notes for\r\na specific program or library.  I'm not\
      \ going to find out about the brokenness\r\nuntil I try to use the program the\
      \ next time.\r\n\r\nIf I'm lucky the program will have a \"this feature is now\
      \ deprecated, read the\r\ndocs\" error message.  That's still a pain, but at\
      \ least it's less confusing than\r\njust getting a traceback, or worst of all:\
      \ silently changing the behavior of\r\na feature.\r\n\r\nProgress\r\n--------\r\
      \n\r\nI completely understand that when moving *backwards* to an older version\r\
      \nI should expect problems.  The older version hasn't had the benefit of the\
      \ extra\r\nwork done on the new version, so of course it should be less stable.\r\
      \n\r\nBut when I'm *updating* to a higher version number the software should\
      \ be\r\n*better* and *more stable*!  It has had more work done on it, and I\
      \ assume no\r\none is actively trying to make software worse, so why does something\
      \ that\r\npreviously worked no longer work?\r\n\r\nWe're supposed to be making\
      \ *progress* as we move forward.  The software has had\r\n*more* work done on\
      \ it, why does it not function correctly *now* when it\r\nfunctioned correctly\
      \ *before*?\r\n\r\nYes, this means developers will need to add extra code to\
      \ handle old\r\ninput/configuration.  Yes, this is a pain in the ass, but *the\
      \ entire point of\r\nmost software is to save people time by automating things*.\
      \  Again, every\r\nbackwards-incompatible change costs the world an amount of\
      \ time:\r\n\r\n    Number of people         Time it takes each person\r\n  \
      \  using that part of     X      to figure out what changed\r\n    the program\
      \                  and how to fix it\r\n\r\nIf our goal is to *save time* then\
      \ we should not make changes that *cost time*.\r\nOr at least we should not\
      \ make such changes lightly.\r\n\r\nA Culture of Sadness\r\n--------------------\r\
      \n\r\nProof that this is a real issue can be found in the tools we use every\
      \ day.  As\r\nprogrammers we've invented elaborate dependency systems to deal\
      \ with it.\r\n\r\nWe say \"pip install django==1.3\" or put \"[clojure \"1.2\"\
      ]\" in our Leiningen\r\nproject.clj files to avoid using the newest versions\
      \ because they'll break.\r\n\r\nStep back and look at this for a second.\r\n\
      \r\nWhat the hell?\r\n\r\nWhat the *hell*?\r\n\r\nWe have invented software\
      \ with features designed to help us use *old* versions\r\nof other software!\r\
      \n\r\nWe have *written code* to *avoid* using the \"latest and greatest\" software!\r\
      \n\r\nObviously this is not entirely bad, but the fact that manually specifying\r\
      \nversion numbers to avoid running *newer* code is commonplace, expected, and\r\
      \na \"best practice\" horrifies me.\r\n\r\nI would *love* to be able to say\
      \ something like this in my requirements.txt and\r\nproject.clj files:\r\n\r\
      \n    Of *course* I want the latest version of library X!  I want *all* the\r\
      \n    newest bug fixes and improvements!\r\n\r\nUnfortunately I can't do that\
      \ right now because so many projects make backwards\r\nincompatible changes\
      \ all the time.\r\n\r\nThe moment I try to build the project at some point in\
      \ the future I'll be sent\r\non a wild goose chase to figure out what function\
      \ moved into what other\r\nnamespace and what other function was split into\
      \ its own library and dammit the\r\ndocumentation on the project's website is\
      \ autogenerated from the tip of its git\r\nrepo and so it doesn't apply to the\
      \ latest actual version and jesus christ\r\nI think I'll just quit programming\
      \ and teach dance full time instead even though\r\nI'll go hungry.\r\n\r\nThe\
      \ Tradeoff\r\n------------\r\n\r\nOne could argue that sometimes backwards incompatible\
      \ changes cost time up front\r\nbut save time in the long run by making the\
      \ software more \"elegant\" and \"lean\".\r\n\r\nWhile I'm sure there are cases\
      \ where this is true, I feel like it's a cop out\r\nmost of the time.  Allow\
      \ me to illustrate this with a helpful Venn diagram:\r\n\r\n               \
      \                     -------\r\n                                   /3333333\\\
      \r\n                                  |333333333|\r\n                      \
      \             \\3333333/\r\n                                    -------\r\n\r\
      \n    11 -> People who give a shit what a program's codebase\r\n    11    looks\
      \ like.\r\n\r\n    22 -> The authors of said program.\r\n    22\r\n\r\nFor libraries\
      \ where the author is the only user, none of this rant applies.\r\nYou're free!\
      \  Break as much as you like!\r\n\r\nFor the majority of libraries, however,\
      \ there are probably vastly more \"users\"\r\nthan \"authors\".  Saving a few\
      \ hours of the authors' own time has to be weighed\r\nagainst the 10 minutes\
      \ each that the hundreds of users will have to spend\r\nfiguring out what happened\
      \ and working around it.\r\n\r\nI want to be clear: being backwards compatible\
      \ *doesn't* mean sacrificing new\r\nfeatures!  New features can still be added!\
      \  Refactoring can still happen!\r\n\r\nIn most cases keeping backwards compatibility\
      \ simply means maintaining a bit of\r\nwrapper code to support people using\
      \ the previous version.\r\n\r\nFor example: in Python, if we moved the public\
      \ foo() function to a new module,\r\nwe'd put the following line in the original\
      \ module:\r\n\r\n    from newmodule import new_foo as foo\r\n\r\nIs it pretty?\
      \  Hell no!  But this single line of code will probably save more\r\npeople\
      \ more time than most of the other lines in the project!\r\n\r\nThis may just\
      \ be an artifact of how my brain is wired, but I actually get\r\na sense of\
      \ satisfaction from writing code that bridges the gap between older\r\nversions\
      \ and new.\r\n\r\nI can almost hear a little voice in my head saying:\r\n\r\n\
      \    \"Mwahaha, I'll slip this refactoring past them and they'll never even\
      \ know\r\n    it happened!\"\r\n\r\nMaybe it's just me, but I think that \"\
      glue\" code can be clever and beautiful in\r\nits own right.\r\n\r\nIt may not\
      \ bring a smile to anyone's face like a shiny new feature, but it\r\nprevents\
      \ many frowns instead, and preventing a frown makes the world a happier\r\n\
      place just as much as creating a smile!\r\n\r\nExceptions\r\n----------\r\n\r\
      \nOne case where I feel the backwards incompatibility tradeoff *is* worth it\
      \ is\r\nsecurity.\r\n\r\nA good example of this is Django's change which made\
      \ AJAX requests no longer be\r\nexempt from CSRF checks.  It was backwards incompatible\
      \ and I'm sure it broke\r\nsome people's projects, but I think it was the right\
      \ thing to do because it\r\nimproved security.\r\n\r\nI also think it's unreasonable\
      \ to expect all software to be perfectly ready from\r\nits first day.\r\n\r\n\
      Sometimes software needs to get poked and prodded in the real world before it's\r\
      \nfully baked, and until then requiring strict backwards compatibility will\
      \ do\r\nmore harm than good.\r\n\r\nBy all means, backwards compatibility should\
      \ be thrown to the wind in the first\r\nstage of a project's life.  At the beginning\
      \ it needs to find its legs, like\r\na baby gazelle on the Serengeti.  But at\
      \ some point the project needs to get its\r\nbalance, grow up, and start concerning\
      \ itself with backwards compatibility.\r\n\r\nBut when should that happen?\r\
      \n\r\nA Solution\r\n----------\r\n\r\nI think there's a simple, intuitive way\
      \ to mark the transition of a piece of\r\nsoftware from \"volatile\" to \"stable\"\
      :\r\n\r\n    Version 1.0\r\n\r\nBefore version 1, software can change and evolve\
      \ rapidly with no regards for\r\nbreaking, but once that first number becomes\
      \ \"greater than or equal to 1\" it's\r\ntime to be a responsible member of\
      \ the software community and start thinking\r\nabout the real humans whose time\
      \ gets wasted for every breaking change.\r\n\r\nThis is the approach semantic\
      \ versioning takes, and I think it's the right one.\r\n\r\nI know a lot of people\
      \ dislike semantic versioning.  They hate how requires\r\nincrementing the major\
      \ version number every time a breaking change is made.\r\n\r\nI consider it\
      \ to be a *good* thing.\r\n\r\nYou *should* pause and carefully consider making\
      \ a change that will break\r\npeople's current code.\r\n\r\nYou *should* be\
      \ ashamed if your project is at version 43.0.0 because you've made\r\n42 breaking\
      \ changes.  That's 43 times you've disregarded your users' time!\r\nThat's a\
      \ bad thing!\r\n\r\nAs programmers we need to start caring about the people\
      \ we write software for.\r\n\r\nBefore making a change that's going to cause\
      \ other people pain, we should ask\r\nourselves if it's really worth the cost.\
      \  Sometimes it is, but many times it's\r\nnot, and we can wrap the change up\
      \ so it doesn't hurt anyone.\r\n\r\nSo please, before you make that backwards\
      \ incompatible change, think of the\r\nother human beings who are going to smack\
      \ their monitors when your software\r\nbreaks.\r\n\r\nFurther Reading\r\n-------------"
    date: [2012, 4, 22]
    subject: '[The Listserve] Volatile Software'
  post_html: {body: '<p>I want to use my fifteen minutes of fame on The Listserve
      to rant about<br />something that''s close to my heart: the stability of the
      software I use.</p>

      <p>NOTE: This is written for people who create software.  If you don''t do that
      you<br />probably won''t find this very interesting.  Sorry!  Maybe you could
      read Text<br />from Dog if you haven''t seen it already?  Either way, have a
      nice<br />morning/afternoon/evening!</p>

      <p>The Situation<br />-------------</p>

      <p>Every time I get a new computer, I go through the same song and dance:</p>

      <p>1. Look at what programs and packages I have installed on the old computer.<br
      />2. Install these programs on the new computer.<br />3. Copy over my configuration
      files from the old computer to the new one.<br />4. Spend the rest of my day
      fixing all the things that broke because I''m using<br />    a newer version
      of program X.</p>

      <p>Step 4 is always the most painful part of getting a new machine.  Always.</p>

      <p>Without fail I spend several hours tweaking configuration files, adjusting
      my<br />workflow, and so on because I''ve upgraded to a new version of foo which
      doesn''t<br />support option X any more or requires library Y version N+1 now.</p>

      <p>Getting a new computer should be a *pleasant* experience!  The unboxing from
      the<br />sleek packaging, that "new laptop" smell, the nostalgia of the default
      desktop<br />image.  Why does this horrible step 4 have to exist and how can
      we get rid of<br />it?</p>

      <p>The Divide<br />----------</p>

      <p>I''ve noticed something interesting lately: I can categorize almost *all*
      of the<br />software I use into two distinct groups:</p>

      <p>* Software that breaks pretty much *every* time I update it (e.g. weechat,<br
      />  offlineimap, Clojure, many Python packages, Skype).<br />* Software that
      almost *never* breaks when I update it (e.g. Mercurial, git,<br />  tmux, Python,
      ack, zsh, Vim, Dropbox).</p>

      <p>Software that falls in between these two extremes is surprisingly rare.  There<br
      />seems to be a pretty clean divide between the two groups.</p>

      <p>This makes me think that there''s some special attribute or quality of the<br
      />second group (or its authors) which the first one lacks.</p>

      <p>Brokenness<br />----------</p>

      <p>I think it''s important that I nail down what I mean by "breaks" or "is broken".<br
      />I don''t necessarily just mean the introduction of "new bugs".</p>

      <p>When I say that a program "breaks", I mean:</p>

      <p>* When I update from version X to version Y of a program, library, or language...<br
      />* Without changing my configuration files, source code, etc...<br />* The
      resulting combination doesn''t work properly</p>

      <p>In effect, I''m saying that "breaking backwards compatibility" means "the
      program<br />is broken"!</p>

      <p>This may be a strong statement, but I stand by it in most cases.</p>

      <p>Backwards compatibility matters!  Every time someone makes a backwards<br
      />incompatible change in a program or library, they cost the world the following<br
      />amount of time:</p>

      <p>    Number of people          Time it takes each person<br />    using that
      part of      X    to figure out what changed<br />    the program                   and
      how to fix it<br /> <br />Often this can be a significant amount of time!</p>

      <p>The Process of Updating<br />-----------------------</p>

      <p>When pointing out a backwards incompatible change to someone, you''ll often
      get<br />a response similar to this:</p>

      <p>    "Well, I mentioned that backwards incompatibility in the changelog, so
      what<br />    the hell, man!"</p>

      <p>This is not a satisfactory answer.</p>

      <p>When I''m updating a piece of software there''s a good chance it''s not because
      I''m<br />specifically updating *that program*.  I might be:</p>

      <p>* Moving to a new computer.<br />* Running a "$PACKAGE_MANAGER update" command.<br
      />* Moving a website to a bigger VPS and reinstalling all the libraries.</p>

      <p>In those cases (and many others) I''m not reading the release notes for<br
      />a specific program or library.  I''m not going to find out about the brokenness<br
      />until I try to use the program the next time.</p>

      <p>If I''m lucky the program will have a "this feature is now deprecated, read
      the<br />docs" error message.  That''s still a pain, but at least it''s less
      confusing than<br />just getting a traceback, or worst of all: silently changing
      the behavior of<br />a feature.</p>

      <p>Progress<br />--------</p>

      <p>I completely understand that when moving *backwards* to an older version<br
      />I should expect problems.  The older version hasn''t had the benefit of the
      extra<br />work done on the new version, so of course it should be less stable.</p>

      <p>But when I''m *updating* to a higher version number the software should be<br
      />*better* and *more stable*!  It has had more work done on it, and I assume
      no<br />one is actively trying to make software worse, so why does something
      that<br />previously worked no longer work?</p>

      <p>We''re supposed to be making *progress* as we move forward.  The software
      has had<br />*more* work done on it, why does it not function correctly *now*
      when it<br />functioned correctly *before*?</p>

      <p>Yes, this means developers will need to add extra code to handle old<br />input/configuration.  Yes,
      this is a pain in the ass, but *the entire point of<br />most software is to
      save people time by automating things*.  Again, every<br />backwards-incompatible
      change costs the world an amount of time:</p>

      <p>    Number of people         Time it takes each person<br />    using that
      part of     X      to figure out what changed<br />    the program                  and
      how to fix it</p>

      <p>If our goal is to *save time* then we should not make changes that *cost
      time*.<br />Or at least we should not make such changes lightly.</p>

      <p>A Culture of Sadness<br />--------------------</p>

      <p>Proof that this is a real issue can be found in the tools we use every day.  As<br
      />programmers we''ve invented elaborate dependency systems to deal with it.</p>

      <p>We say "pip install django==1.3" or put "[clojure "1.2"]" in our Leiningen<br
      />project.clj files to avoid using the newest versions because they''ll break.</p>

      <p>Step back and look at this for a second.</p>

      <p>What the hell?</p>

      <p>What the *hell*?</p>

      <p>We have invented software with features designed to help us use *old* versions<br
      />of other software!</p>

      <p>We have *written code* to *avoid* using the "latest and greatest" software!</p>

      <p>Obviously this is not entirely bad, but the fact that manually specifying<br
      />version numbers to avoid running *newer* code is commonplace, expected, and<br
      />a "best practice" horrifies me.</p>

      <p>I would *love* to be able to say something like this in my requirements.txt
      and<br />project.clj files:</p>

      <p>    Of *course* I want the latest version of library X!  I want *all* the<br
      />    newest bug fixes and improvements!</p>

      <p>Unfortunately I can''t do that right now because so many projects make backwards<br
      />incompatible changes all the time.</p>

      <p>The moment I try to build the project at some point in the future I''ll be
      sent<br />on a wild goose chase to figure out what function moved into what
      other<br />namespace and what other function was split into its own library
      and dammit the<br />documentation on the project''s website is autogenerated
      from the tip of its git<br />repo and so it doesn''t apply to the latest actual
      version and jesus christ<br />I think I''ll just quit programming and teach
      dance full time instead even though<br />I''ll go hungry.</p>

      <p>The Tradeoff<br />------------</p>

      <p>One could argue that sometimes backwards incompatible changes cost time up
      front<br />but save time in the long run by making the software more "elegant"
      and "lean".</p>

      <p>While I''m sure there are cases where this is true, I feel like it''s a cop
      out<br />most of the time.  Allow me to illustrate this with a helpful Venn
      diagram:</p>

      <p>                                    -------<br />                                   /3333333\<br
      />                                  |333333333|<br />                                   \3333333/<br
      />                                    -------</p>

      <p>    11 -&gt; People who give a shit what a program''s codebase<br />    11    looks
      like.</p>

      <p>    22 -&gt; The authors of said program.<br />    22</p>

      <p>For libraries where the author is the only user, none of this rant applies.<br
      />You''re free!  Break as much as you like!</p>

      <p>For the majority of libraries, however, there are probably vastly more "users"<br
      />than "authors".  Saving a few hours of the authors'' own time has to be weighed<br
      />against the 10 minutes each that the hundreds of users will have to spend<br
      />figuring out what happened and working around it.</p>

      <p>I want to be clear: being backwards compatible *doesn''t* mean sacrificing
      new<br />features!  New features can still be added!  Refactoring can still
      happen!</p>

      <p>In most cases keeping backwards compatibility simply means maintaining a
      bit of<br />wrapper code to support people using the previous version.</p>

      <p>For example: in Python, if we moved the public foo() function to a new module,<br
      />we''d put the following line in the original module:</p>

      <p>    from newmodule import new_foo as foo</p>

      <p>Is it pretty?  Hell no!  But this single line of code will probably save
      more<br />people more time than most of the other lines in the project!</p>

      <p>This may just be an artifact of how my brain is wired, but I actually get<br
      />a sense of satisfaction from writing code that bridges the gap between older<br
      />versions and new.</p>

      <p>I can almost hear a little voice in my head saying:</p>

      <p>    "Mwahaha, I''ll slip this refactoring past them and they''ll never even
      know<br />    it happened!"</p>

      <p>Maybe it''s just me, but I think that "glue" code can be clever and beautiful
      in<br />its own right.</p>

      <p>It may not bring a smile to anyone''s face like a shiny new feature, but
      it<br />prevents many frowns instead, and preventing a frown makes the world
      a happier<br />place just as much as creating a smile!</p>

      <p>Exceptions<br />----------</p>

      <p>One case where I feel the backwards incompatibility tradeoff *is* worth it
      is<br />security.</p>

      <p>A good example of this is Django''s change which made AJAX requests no longer
      be<br />exempt from CSRF checks.  It was backwards incompatible and I''m sure
      it broke<br />some people''s projects, but I think it was the right thing to
      do because it<br />improved security.</p>

      <p>I also think it''s unreasonable to expect all software to be perfectly ready
      from<br />its first day.</p>

      <p>Sometimes software needs to get poked and prodded in the real world before
      it''s<br />fully baked, and until then requiring strict backwards compatibility
      will do<br />more harm than good.</p>

      <p>By all means, backwards compatibility should be thrown to the wind in the
      first<br />stage of a project''s life.  At the beginning it needs to find its
      legs, like<br />a baby gazelle on the Serengeti.  But at some point the project
      needs to get its<br />balance, grow up, and start concerning itself with backwards
      compatibility.</p>

      <p>But when should that happen?</p>

      <p>A Solution<br />----------</p>

      <p>I think there''s a simple, intuitive way to mark the transition of a piece
      of<br />software from "volatile" to "stable":</p>

      <p>    Version 1.0</p>

      <p>Before version 1, software can change and evolve rapidly with no regards
      for<br />breaking, but once that first number becomes "greater than or equal
      to 1" it''s<br />time to be a responsible member of the software community and
      start thinking<br />about the real humans whose time gets wasted for every breaking
      change.</p>

      <p>This is the approach semantic versioning takes, and I think it''s the right
      one.</p>

      <p>I know a lot of people dislike semantic versioning.  They hate how requires<br
      />incrementing the major version number every time a breaking change is made.</p>

      <p>I consider it to be a *good* thing.</p>

      <p>You *should* pause and carefully consider making a change that will break<br
      />people''s current code.</p>

      <p>You *should* be ashamed if your project is at version 43.0.0 because you''ve
      made<br />42 breaking changes.  That''s 43 times you''ve disregarded your users''
      time!<br />That''s a bad thing!</p>

      <p>As programmers we need to start caring about the people we write software
      for.</p>

      <p>Before making a change that''s going to cause other people pain, we should
      ask<br />ourselves if it''s really worth the cost.  Sometimes it is, but many
      times it''s<br />not, and we can wrap the change up so it doesn''t hurt anyone.</p>

      <p>So please, before you make that backwards incompatible change, think of the<br
      />other human beings who are going to smack their monitors when your software<br
      />breaks.</p>

      <p>Further Reading<br />-------------</p>', date: April 22 2012, desc: 'The
      Listserve post on April 22, 2012: &quot;Volatile Software&quot;', title: Volatile
      Software}
layout: post
tags: ['2012-04-22']
title: Volatile Software

---
